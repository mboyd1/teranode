package smoke

import (
	"encoding/json"
	"strings"
	"sync"
	"testing"
	"time"

	"github.com/bsv-blockchain/teranode/daemon"
	"github.com/bsv-blockchain/teranode/model"
	"github.com/bsv-blockchain/teranode/settings"
	"github.com/bsv-blockchain/teranode/test"
	helper "github.com/bsv-blockchain/teranode/test/utils"
	"github.com/bsv-blockchain/teranode/test/utils/svnode"
	"github.com/stretchr/testify/require"
)

var legacySyncTestLock sync.Mutex

// newSVNode creates an SVNode using Docker via testcontainers
func newSVNode() svnode.SVNodeI {
	return svnode.New(svnode.DefaultOptions())
}

// TestLegacySync tests that teranode can sync blocks from svnode
//
// This test:
// 1. Starts svnode in Docker
// 2. Generates blocks on svnode
// 3. Starts teranode with legacy enabled, connecting to svnode
// 4. Verifies teranode catches up to svnode's block height
func TestLegacySync(t *testing.T) {
	legacySyncTestLock.Lock()
	defer legacySyncTestLock.Unlock()

	ctx := t.Context()

	// Start svnode in Docker
	sv := newSVNode()
	err := sv.Start(ctx)
	require.NoError(t, err, "Failed to start svnode")

	defer func() {
		_ = sv.Stop(ctx)
	}()

	// Generate 101 blocks on svnode (enough for coinbase maturity)
	const targetHeight = 101
	_, err = sv.Generate(targetHeight)
	require.NoError(t, err, "Failed to generate blocks on svnode")

	// Verify svnode has blocks
	blockCount, err := sv.GetBlockCount()
	require.NoError(t, err)
	require.Equal(t, targetHeight, blockCount, "SVNode should have %d blocks", targetHeight)

	t.Logf("SVNode started with %d blocks", blockCount)

	// Start teranode with legacy enabled, connecting to svnode
	td := daemon.NewTestDaemon(t, daemon.TestOptions{
		EnableRPC:       true,
		EnableP2P:       true,
		EnableLegacy:    true,
		EnableValidator: true,
		SettingsOverrideFunc: test.ComposeSettings(
			test.SystemTestSettings(),
			func(settings *settings.Settings) {
				settings.Legacy.ConnectPeers = []string{sv.P2PHost()}
				settings.P2P.StaticPeers = []string{}
			},
		),
	})

	defer td.Stop(t)

	// Wait for teranode to sync to svnode's height
	err = helper.WaitForNodeBlockHeight(ctx, td.BlockchainClient, uint32(targetHeight), 60*time.Second)
	require.NoError(t, err, "Teranode failed to sync to svnode's block height")

	t.Logf("Teranode synced to height %d from svnode", targetHeight)

	// Verify peer connection via RPC
	resp, err := td.CallRPC(ctx, "getpeerinfo", []any{})
	require.NoError(t, err)

	var p2pResp helper.P2PRPCResponse
	err = json.Unmarshal([]byte(resp), &p2pResp)
	require.NoError(t, err)

	// Find peer connected to svnode's P2P port
	var legacyPeers []string
	for _, peer := range p2pResp.Result {
		if strings.Contains(peer.Addr, ":18333") {
			legacyPeers = append(legacyPeers, peer.Addr)
		}
	}
	require.GreaterOrEqual(t, len(legacyPeers), 1, "Teranode should be connected to svnode")

	t.Logf("Teranode connected to %d legacy peer(s)", len(legacyPeers))
}

// TestSVNodeSyncFromTeranode tests that svnode can sync blocks from teranode
// This validates that blocks generated by teranode are valid according to legacy node consensus rules
//
// This test:
// 1. Starts svnode in Docker
// 2. Generates 1 block on svnode (required for svnode to accept blocks from pruned node)
// 3. Starts teranode with legacy enabled, connecting to svnode
// 4. Generates blocks on teranode
// 5. Verifies svnode catches up to teranode's block height
func TestSVNodeSyncFromTeranode(t *testing.T) {
	legacySyncTestLock.Lock()
	defer legacySyncTestLock.Unlock()

	ctx := t.Context()

	// // Start svnode in Docker
	// sv := newSVNode()
	// err := sv.Start(ctx)
	// require.NoError(t, err, "Failed to start svnode")

	// defer func() {
	// 	_ = sv.Stop(ctx)
	// }()

	// Important: svnode won't accept blocks from a pruned node (teranode)
	// until it has at least 1 block on top of genesis
	// _, err = sv.Generate(1)
	// require.NoError(t, err, "Failed to generate initial block on svnode")

	t.Log("SVNode started with 1 block")

	// Start teranode with legacy enabled
	td := daemon.NewTestDaemon(t, daemon.TestOptions{
		EnableRPC:       true,
		EnableP2P:       true,
		EnableValidator: true,
		// PreserveDataDir:   true,
		EnableBlockPersister: true,
		// EnableDebugLogging: true,
		SettingsOverrideFunc: test.ComposeSettings(
			test.SystemTestSettings(),
			// func(s *settings.Settings) {
			// 	s.Legacy.AllowSyncCandidateFromLocalPeers = true
			// 	s.Legacy.ConnectPeers = []string{sv.P2PHost()}
			// 	s.Legacy.Upnp = true
			// },
		),
	})

	err := td.BlockchainClient.Run(td.Ctx, "test")
	require.NoError(t, err, "failed to initialize blockchain")
	defer td.Stop(t)

	// t.Log("Teranode synced initial block from svnode")

	// Generate blocks on teranode
	const teranodeBlocks = 5
	const targetHeight = teranodeBlocks

	// Generate blocks with slight delay - svnode complains about timestamps otherwise
	var minedBlocks []*model.Block
	for i := 0; i < teranodeBlocks; i++ {
		time.Sleep(500 * time.Millisecond)
		block := td.MineAndWait(t, 1)
		minedBlocks = append(minedBlocks, block)
	}

	t.Logf("Generated %d blocks on teranode", teranodeBlocks)

	// Wait for all blocks to be persisted before restarting with legacy
	for i, block := range minedBlocks {
		err = td.WaitForBlockPersisted(block.Hash(), 30*time.Second)
		require.NoError(t, err, "Block %d was not persisted within timeout", i+1)
	}
	t.Log("All blocks persisted")

	td.Stop(t)
	td.ResetServiceManagerContext(t)

	td = daemon.NewTestDaemon(t, daemon.TestOptions{
		EnableRPC:       true,
		EnableP2P:       true,
		EnableValidator: true,
		// PreserveDataDir:   true,
		EnableBlockPersister: true,
		// EnableDebugLogging: true,
		EnableLegacy:      true,
		SkipRemoveDataDir: true,
		SettingsOverrideFunc: test.ComposeSettings(
			test.SystemTestSettings(),
			func(s *settings.Settings) {
				s.Legacy.AllowSyncCandidateFromLocalPeers = true
				s.Legacy.ConnectPeers = []string{"localhost:18333"}
				s.Legacy.Upnp = true
			},
		),
	})

	defer td.Stop(t)

	// Start svnode in Docker
	sv := newSVNode()
	err = sv.Start(td.Ctx)
	require.NoError(t, err, "Failed to start svnode")

	defer func() {
		_ = sv.Stop(td.Ctx)
	}()

	// Test getpeerinfo
	resp, err := td.CallRPC(td.Ctx, "getpeerinfo", []any{})
	require.NoError(t, err, "Failed to call getpeerinfo")

	var getPeerInfoResp helper.P2PRPCResponse
	err = json.Unmarshal([]byte(resp), &getPeerInfoResp)
	require.NoError(t, err)

	td.LogJSON(t, "getPeerInfo", getPeerInfoResp)

	// Verify the response structure
	require.Nil(t, getPeerInfoResp.Error, "Should not have an error")
	require.NotNil(t, getPeerInfoResp.Result, "Result should not be nil")

	_, err = sv.Generate(1)
	require.NoError(t, err, "Failed to generate initial block on svnode")

	// Wait for svnode to sync from teranode
	err = sv.WaitForBlockHeight(ctx, targetHeight, 30*time.Second)
	require.NoError(t, err, "SVNode failed to sync blocks from teranode")

	// Verify final state
	svBlockCount, err := sv.GetBlockCount()
	require.NoError(t, err)
	require.Equal(t, targetHeight, svBlockCount, "SVNode should have synced to height %d", targetHeight)

	t.Logf("SVNode synced to height %d from teranode - blocks validated by legacy consensus", targetHeight)
}

// TestBidirectionalSync tests bidirectional sync between teranode and svnode
// This validates that both nodes can generate blocks and the other will sync
//
// This test uses the persist pattern:
// 1. SVNode generates initial blocks
// 2. Teranode (with legacy) syncs from SVNode
// 3. Teranode restarts without legacy, generates blocks with persister
// 4. Teranode restarts with legacy, SVNode syncs teranode's blocks
// 5. SVNode generates more blocks, teranode syncs
func TestBidirectionalSync(t *testing.T) {
	legacySyncTestLock.Lock()
	defer legacySyncTestLock.Unlock()

	ctx := t.Context()

	// Start svnode in Docker
	sv := newSVNode()
	err := sv.Start(ctx)
	require.NoError(t, err, "Failed to start svnode")

	defer func() {
		_ = sv.Stop(ctx)
	}()

	// Generate initial blocks on svnode
	const initialBlocks = 10
	_, err = sv.Generate(initialBlocks)
	require.NoError(t, err, "Failed to generate initial blocks on svnode")

	t.Logf("SVNode generated %d initial blocks", initialBlocks)

	// Phase 1: Start teranode WITH legacy to sync from SVNode
	td := daemon.NewTestDaemon(t, daemon.TestOptions{
		EnableRPC:            true,
		EnableP2P:            true,
		EnableLegacy:         true,
		EnableValidator:      true,
		EnableBlockPersister: true,
		SettingsOverrideFunc: test.ComposeSettings(
			test.SystemTestSettings(),
			func(s *settings.Settings) {
				s.Legacy.AllowSyncCandidateFromLocalPeers = true
				s.Legacy.ConnectPeers = []string{sv.P2PHost()}
				s.P2P.StaticPeers = []string{}
			},
		),
	})

	// Wait for teranode to sync initial blocks from svnode
	err = helper.WaitForNodeBlockHeight(ctx, td.BlockchainClient, uint32(initialBlocks), 30*time.Second)
	require.NoError(t, err, "Teranode failed to sync initial blocks")

	t.Log("Teranode synced initial blocks from SVNode")

	// wait for teranode to persist blocks
	// get block at each height and check for persistence
	for i := 1; i <= initialBlocks; i++ {
		block, err := td.BlockchainClient.GetBlockByHeight(ctx, uint32(i))
		require.NoError(t, err, "Failed to get block at height %d", i)
		require.NotNil(t, block, "Block at height %d should not be nil", i)
		err = td.WaitForBlockPersisted(block.Hash(), 30*time.Second)
		require.NoError(t, err, "Block %d was not persisted within timeout", i)
	}

	// // Stop teranode to restart without legacy for block generation
	td.Stop(t)
	td.ResetServiceManagerContext(t)

	// Phase 2: Restart teranode WITHOUT legacy to generate blocks with persister
	td = daemon.NewTestDaemon(t, daemon.TestOptions{
		EnableRPC:            true,
		EnableP2P:            true,
		EnableValidator:      true,
		EnableBlockPersister: true,
		SkipRemoveDataDir:    true,
		SettingsOverrideFunc: test.ComposeSettings(
			test.SystemTestSettings(),
		),
	})

	err = td.BlockchainClient.Run(td.Ctx, "test")
	require.NoError(t, err, "failed to initialize blockchain")

	// Generate blocks on teranode (without legacy connection)
	const teranodeBlocks = 5
	var teranodeMinedBlocks []*model.Block
	for i := 0; i < teranodeBlocks; i++ {
		time.Sleep(500 * time.Millisecond)
		block := td.MineAndWait(t, 1)
		teranodeMinedBlocks = append(teranodeMinedBlocks, block)
	}

	currentHeight := initialBlocks + teranodeBlocks
	t.Logf("Teranode generated %d more blocks, current height: %d", teranodeBlocks, currentHeight)

	// Wait for all blocks to be persisted before restarting with legacy
	for i, block := range teranodeMinedBlocks {
		err = td.WaitForBlockPersisted(block.Hash(), 30*time.Second)
		require.NoError(t, err, "Block %d was not persisted within timeout", i+1)
	}
	t.Log("All teranode blocks persisted")

	// // Stop teranode to restart with legacy
	td.Stop(t)
	td.ResetServiceManagerContext(t)

	// Phase 3: Restart teranode WITH legacy so SVNode can sync
	td = daemon.NewTestDaemon(t, daemon.TestOptions{
		EnableRPC:            true,
		EnableP2P:            true,
		EnableValidator:      true,
		EnableBlockPersister: true,
		EnableLegacy:         true,
		SkipRemoveDataDir:    true,
		SettingsOverrideFunc: test.ComposeSettings(
			test.SystemTestSettings(),
			func(s *settings.Settings) {
				s.Legacy.AllowSyncCandidateFromLocalPeers = true
				s.Legacy.ConnectPeers = []string{sv.P2PHost()}
				s.P2P.StaticPeers = []string{}
			},
		),
	})

	defer td.Stop(t)

	// svnode has to generate a block to trigger sync
	_, err = sv.Generate(1)
	require.NoError(t, err, "Failed to generate block on svnode to trigger sync")

	// Wait for svnode to sync teranode's blocks
	err = sv.WaitForBlockHeight(ctx, currentHeight, 30*time.Second)
	require.NoError(t, err, "SVNode failed to sync teranode blocks")

	t.Log("SVNode synced teranode's blocks")

	// Phase 4: SVNode generates more blocks, teranode syncs
	const moreBlocks = 5
	_, err = sv.Generate(moreBlocks)
	require.NoError(t, err, "Failed to generate more blocks on svnode")

	finalHeight := currentHeight + moreBlocks - 1
	t.Logf("SVNode generated %d more blocks, target height: %d", moreBlocks, finalHeight)

	// Wait for teranode to sync svnode's new blocks
	err = helper.WaitForNodeBlockHeight(ctx, td.BlockchainClient, uint32(finalHeight), 30*time.Second)
	require.NoError(t, err, "Teranode failed to sync svnode's new blocks")

	// Verify both nodes are at the same height
	// svBlockCount, err := sv.GetBlockCount()
	// require.NoError(t, err)

	header, _, err := td.BlockchainClient.GetBestBlockHeader(ctx)
	require.NoError(t, err)

	// require.Equal(t, finalHeight, svBlockCount, "SVNode height mismatch")
	// require.Equal(t, uint32(finalHeight), meta.Height, "Teranode height mismatch")

	// Verify both nodes have the same best block hash
	svBestHash, err := sv.GetBestBlockHash()
	require.NoError(t, err)

	teranodeBestHash := header.Hash().String()
	require.Equal(t, svBestHash, teranodeBestHash, "Best block hash should match between svnode and teranode")

	t.Logf("Bidirectional sync complete - both nodes at height %d with hash %s", finalHeight, svBestHash)
}

// TestSVNodeValidatesTeranodeBlocks specifically tests that blocks generated by teranode
// pass validation by svnode's consensus rules
//
// This test uses the persist pattern:
// 1. SVNode generates 1 block (required for accepting blocks from pruned node)
// 2. Teranode (without legacy, with persister) generates blocks
// 3. Teranode restarts with legacy
// 4. SVNode syncs and validates each block
func TestSVNodeValidatesTeranodeBlocks(t *testing.T) {
	t.Skip()
	legacySyncTestLock.Lock()
	defer legacySyncTestLock.Unlock()

	ctx := t.Context()

	// Phase 1: Start teranode WITHOUT legacy to generate blocks with persister
	td := daemon.NewTestDaemon(t, daemon.TestOptions{
		EnableRPC:            true,
		EnableP2P:            true,
		EnableValidator:      true,
		EnableBlockPersister: true,
		// PreserveDataDir: true,
		SettingsOverrideFunc: test.ComposeSettings(
			test.SystemTestSettings(),
		),
	})

	err := td.BlockchainClient.Run(td.Ctx, "test")
	require.NoError(t, err, "failed to initialize blockchain")

	// Generate multiple blocks on teranode
	const blocksToGenerate = 10
	var generatedBlocks []*model.Block
	for i := 0; i < blocksToGenerate; i++ {
		time.Sleep(500 * time.Millisecond)
		block := td.MineAndWait(t, 1)
		generatedBlocks = append(generatedBlocks, block)
	}

	t.Logf("Teranode generated %d blocks", blocksToGenerate)

	// Wait for all blocks to be persisted before restarting with legacy
	for i, block := range generatedBlocks {
		err = td.WaitForBlockPersisted(block.Hash(), 30*time.Second)
		require.NoError(t, err, "Block %d was not persisted within timeout", i+1)
	}
	t.Log("All blocks persisted")

	// Stop teranode to restart with legacy
	td.Stop(t)
	td.ResetServiceManagerContext(t)

	// Phase 2: Restart teranode WITH legacy so SVNode can sync
	td = daemon.NewTestDaemon(t, daemon.TestOptions{
		EnableRPC:            true,
		EnableP2P:            true,
		EnableValidator:      true,
		EnableBlockPersister: true,
		EnableLegacy:         true,
		SkipRemoveDataDir:    true,
		// PreserveDataDir:      true,
		SettingsOverrideFunc: test.ComposeSettings(
			test.SystemTestSettings(),
			func(s *settings.Settings) {
				s.Legacy.AllowSyncCandidateFromLocalPeers = true
				s.Legacy.ConnectPeers = []string{"localhost:18333"}
			},
		),
	})

	defer td.Stop(t)

	// Start svnode in Docker
	sv := newSVNode()
	err = sv.Start(ctx)
	require.NoError(t, err, "Failed to start svnode")

	defer func() {
		_ = sv.Stop(ctx)
	}()

	// Generate 1 block on svnode (required for accepting blocks from pruned node)
	_, err = sv.Generate(1)
	require.NoError(t, err)

	t.Log("SVNode started with 1 block")

	// Wait for svnode to sync all teranode blocks
	// svnode has 1 initial + 1 trigger block = 2, teranode has blocksToGenerate
	// Final height should be 1 + blocksToGenerate (svnode adopts teranode's chain which is longer)
	finalHeight := blocksToGenerate
	err = sv.WaitForBlockHeight(ctx, finalHeight, 30*time.Second)
	require.NoError(t, err, "SVNode failed to sync blocks from teranode")

	t.Logf("SVNode synced to height %d", finalHeight)

	// Verify each block was validated by svnode
	for i := 2; i <= finalHeight; i++ {
		// Verify the chain is valid on svnode up to this height
		valid, err := sv.VerifyChain(1, i) // Quick verify of last block
		require.NoError(t, err, "Failed to verify chain on svnode")
		require.True(t, valid, "SVNode chain verification failed")
	}

	// Final verification - verify entire chain
	valid, err := sv.VerifyChain(4, finalHeight) // Full verification
	require.NoError(t, err, "Failed to verify full chain on svnode")
	require.True(t, valid, "SVNode full chain verification failed")

	// Verify block hashes match
	svBestHash, err := sv.GetBestBlockHash()
	require.NoError(t, err)

	header, _, err := td.BlockchainClient.GetBestBlockHeader(ctx)
	require.NoError(t, err)

	require.Equal(t, svBestHash, header.Hash().String(), "Block hashes should match")

	t.Logf("All %d teranode blocks validated by svnode - chain integrity confirmed", blocksToGenerate)
}
